#!/usr/bin/env python
"""Module containing functionality to merge existing vCards with the ones generated by the
AkaDressen.
"""
from collections.abc import Sequence
from logging import getLogger
from pathlib import Path
from typing import Callable, Union

import vobject.base

from akadressen._util import ProgressLogger, vcard_name_to_filename

_logger = getLogger()


def merge_vcards(
    directory: Union[str, Path], akadressen_vcards: Sequence[vobject.base.Component]
) -> None:
    """Merges the vCards generated from the AkaDressen with the ones downloaded with
    :class:`akadressen.NCAddressBook.download_all_contacts`. The merged files will be written
    into the ``directory`` overriding existing vCards.

    vCards in the ``directory`` that have no match in ``akadressen_vcards`` will not be touched.

    Entries in ``akadressen_vcards`` that have no matching vCard in the ``directory`` will be
    simply saved as new file.

    If the ``directory`` is a git repository, this makes it easy to double check the applied
    changes.

    Args:
        directory (:obj:`str` | :class:`pathlib.Path`): The directory where the vCards where saved
            to.
        akadressen_vcards (List[:class:`vobject.base.Component`]): The list of vCards generated
            by :meth:`akadressen.get_akadressen_vcards`.
    """
    progress_logger = ProgressLogger(
        _logger, len(akadressen_vcards), message="Processed %d of %d vCards."
    )
    directory = Path(directory)
    for aka_vcard in akadressen_vcards:
        file_name = vcard_name_to_filename(aka_vcard.n.value)
        if (path := directory / file_name).is_file():
            vcard = vobject.readOne(path.read_text(encoding="utf-8"))
            merged_vcard = _merge_vcard(vcard, aka_vcard)
            path.unlink()
            path.write_bytes(merged_vcard.serialize().encode("utf-8"))
        else:
            path.write_bytes(aka_vcard.serialize().encode("utf-8"))

        progress_logger.log()


def _add_element_or_list(vcard: vobject.base.Component, add: object) -> None:
    if isinstance(add, list):
        for element in add:
            vcard.add(element)
        return
    vcard.add(add)


def _merge_entries(
    vcard: vobject.base.Component,
    base_contents: dict[str, vobject.base.Component],
    contents: dict[str, vobject.base.Component],
    key: str,
    base_entries_action: Callable[[vobject.base.Component, vobject.base.Component], None] = None,
) -> None:
    base_entry = base_contents.get(key)
    if merge_entry := contents.get(key):
        if not base_entry:
            _add_element_or_list(vcard, merge_entry)
        else:
            entries = [adr.value for adr in base_entry]
            for entry in merge_entry:
                if entry.value not in entries:
                    base_entry.append(entry)

                if base_entries_action:
                    base_entries_action(base_entry, entry)


def _merge_vcard(
    vcard: vobject.base.Component, aka_vcard: vobject.base.Component
) -> vobject.base.Component:
    base_contents, contents = vcard.contents, aka_vcard.contents

    # No need to check the name - if it wouldn't match, we wouldn't be here

    # First the simple ones
    if not base_contents.get("uid"):
        vcard.add(contents["uid"])
    if not base_contents.get("n"):
        vcard.add(contents["n"][0])
    if not base_contents.get("nickname") and (nickname := contents.get("nickname")):
        _add_element_or_list(vcard, nickname)
    if not base_contents.get("bday") and (b_day := contents.get("bday")):
        if isinstance(b_day, list):
            # For some reason, contents.get returns a list of bdays
            vcard.add(b_day[0])
        else:
            vcard.add(b_day)
    if not base_contents.get("photo") and (photo := contents.get("photo")):
        vcard.add(photo[0])

    # The next need some more elaborate merging logic
    _merge_entries(vcard, base_contents, contents, "email")
    _merge_entries(vcard, base_contents, contents, "tel")

    def _base_entries_action(
        base_address: vobject.base.Component, entry_: vobject.base.Component
    ) -> None:
        # special casing for house number
        for adr in base_address.copy():
            if (
                adr.value.city == entry_.value.city  # pylint: disable=too-many-boolean-expressions
                and adr.value.extended == entry_.value.extended
                and adr.value.region == entry_.value.region
                and adr.value.code == entry_.value.code
                and adr.value.country == entry_.value.country
                and adr.value.street == f"{entry_.value.street} {entry_.value.box}"
            ):
                base_address.remove(adr)

    _merge_entries(vcard, base_contents, contents, "adr", _base_entries_action)

    # Finally the last to are rather special cases â€¦

    # Notes
    base_entry = base_contents.get("note")
    if entry := contents.get("note"):
        if not base_entry:
            _add_element_or_list(vcard, entry)
        else:
            if not all(map(lambda n: isinstance(n, list) and len(n) == 1, [entry, base_entry])):
                raise RuntimeError("Can't process notes")
            if entry[0].value not in base_entry[0].value:
                base_entry[0].value += f"\n{entry[0].value}"

    # Organization
    base_entry = base_contents.get("org")
    entry = contents.get("org")
    if base_entry:
        if not (isinstance(base_entry, list) and isinstance(entry, list)):
            raise RuntimeError("Can't process organization")
        entries = base_entry[0].value
        for entry in entry[0].value:
            if entry not in entries:
                base_entry[0].value.append(entry)

    # full name
    full_name = base_contents.get("fn")
    if not full_name:
        vcard.add(contents["fn"][0])
    else:
        given = contents["n"][0].value.given
        family = contents["n"][0].value.family
        additional = contents["n"][0].value.additional
        possible_values = [f"{given} {family}", f"{family}, {given}"]
        if additional:
            possible_values.extend(
                [f"{given} {additional} {family}", f"{family}, {given} {additional}"]
            )

        if full_name[0].value in possible_values and full_name[0].value != contents["fn"][0].value:
            full_name[0].value = contents["fn"][0].value

    return vcard
